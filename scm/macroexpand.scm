(define (collect-define-macros s-exp context)
  (define (collect-single s-exp)
    (match s-exp
      ((define-macro (,name . ,args) . ,body)
       (list name (eval-lambda args (list (macroexpand `(begin ,@body) context)) context)))
      ((begin . ,inner-s-exps)
       (collect-multiple inner-s-exps))
      (,_ '())))

  (define (collect-multiple s-exps)
    (let loop ((acc '()) (xs s-exps))
      (if (pair? xs)
        (loop (append (collect-single (car xs)) acc) (cdr xs))
        acc)))
  (apply new-map (collect-single s-exp)))

(define (macroexpand-pair s-exps context has-expanded)
  (let loop ((acc '()) (s-exps s-exps))
    (if (null? s-exps)
      (reverse acc)
      (loop (cons (macroexpand-inner (car s-exps) context has-expanded) acc)
            (cdr s-exps)))))

(define (map-quasiquoted-no-expand s-exp fn)
  (match s-exp
    ((,unquote-symbol ,unquoted)
     when: (eq? 'unquote unquote-symbol)
     (list 'unquote (fn unquoted)))
    ((,unquote-splicing-symbol ,unquote-spliced)
     when: (eq? 'unquote-splicing unquote-splicing-symbol)
     (list 'unquote-splicing (fn unquote-spliced)))
    (,pair
     when: (pair? pair)
     (map-quasiquoted-pair-no-expand pair fn))
    (,_ s-exp)))

(define (map-quasiquoted-pair-no-expand s-exps fn)
  (let loop ((acc '()) (s-exps s-exps))
    (match s-exps
      (() (reverse acc))
      ((,s-exp . ,rest)
       (loop (cons (map-quasiquoted-no-expand s-exp fn) acc) rest))
      (,s-exp (reduce (lambda (acc x) (cons x acc)) (map-quasiquoted-no-expand s-exp fn) acc)))))

(define (macroexpand-quasiquoted s-exps context has-expanded)
  (map-quasiquoted-no-expand
   s-exps
   (lambda (s-exp)
     (macroexpand-1 s-exp context has-expanded))))

(define (macroexpand-inner s-exp context has-expanded)
  (match s-exp
    ((define ,sig . ,body)
     `(define ,sig ,@(macroexpand-pair body context has-expanded)))
    ((define-macro ,_1 . ,_2) #!void)
    ((if ,a ,b)
     `(if ,(macroexpand-inner a context has-expanded)
        ,(macroexpand-inner b context has-expanded)))
    ((if ,a ,b ,c)
     `(if ,(macroexpand-inner a context has-expanded)
        ,(macroexpand-inner b context has-expanded)
        ,(macroexpand-inner c context has-expanded)))
    ((quote ,x) s-exp)
    ((quasiquote ,s-exp) `(quasiquote ,(macroexpand-quasiquoted s-exp context has-expanded)))
    ((begin . ,s-exps)
     `(begin ,@(macroexpand-pair s-exps context has-expanded)))
    ((lambda ,args . ,body)
     `(lambda ,args ,@(macroexpand-pair body context has-expanded)))
    ((new ,type-name . ,type-hinted-args)
     `(new ,type-name ,@(map (lambda (type-hinted-arg)
                               (match type-hinted-arg
                                 ((,type-name ,arg)
                                  `(,type-name ,(macroexpand-inner arg context has-expanded)))))
                             type-hinted-args)))
    ((call (,type-name ,target) ,method-name . ,type-hinted-args)
     `(call (,type-name ,(macroexpand-inner target context has-expanded))
            ,method-name
            ,@(map (lambda (type-hinted-arg)
                     (match type-hinted-arg
                       ((,type-name ,arg)
                        `(,type-name ,(macroexpand-inner arg context has-expanded)))))
                   type-hinted-args)))
    ((field (,type-name ,target) ,field-name)
     `(field (,type-name ,(macroexpand-inner target context has-expanded)) ,field-name))
    ((,macro-name . ,args)
     when: (map-contains-key? (ref-deref (map-get context 'macros)) macro-name)
     (let ((proc (map-get (ref-deref (map-get context 'macros)) macro-name)))
       (ref-set! has-expanded #t)
       (guest-apply proc args)))
    (,pair
     when: (pair? pair)
     (macroexpand-pair pair context has-expanded))
    (,literal literal)))

(define (macroexpand-1 s-exp context has-expanded)
  (let* ((collected (collect-define-macros s-exp context))
         (macros (map-merge
                  (ref-deref (map-get context 'macros))
                  collected)))
    (ref-set! (map-get context 'macros) macros)
    (macroexpand-inner s-exp context has-expanded)))

(define (macroexpand s-exp context)
  (let loop ((has-expanded (new-ref #f))
             (s-exp s-exp))
    (let ((next-s-exp (macroexpand-1 s-exp context has-expanded)))
      (if (ref-deref has-expanded)
        (loop (new-ref #f) next-s-exp)
        next-s-exp))))
